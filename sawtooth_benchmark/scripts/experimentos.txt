Ideias que eu tive:

1) Vazão transacional em função da taxa de envio de transação nos clientes.
Baseado no que já foi feito no artigo do AutAvailChain.
Cada cliente envia T transações concorrentemente.
Scripts concorrentes executam em loop transações de anúncio aleatórias.
Mede-se o tempo para que todas as transações sejam validadas.
Um script de tempos em tempos verifica a quantidade de transações por consultas ao validador.
O tempo para se validar uma transação é a latência.
A vazão transacional inicialmente é limitada pela taxa de envio de transações.
Após a taxa de envio de transações ultrapassar a vazão máxima, forma-se uma fila de transações.
As transações descartadas geram um desperdício de capacidade computacional e uma queda na vazão.
No sawtooth, a taxa de envio de transações é muito maior que a taxa de validação das transações.
Pode ser que já com muitos poucos clientes, a vazão máxima seja alcançada.
Alternativa: Controlar a taxa de envio de transações do cliente.
Utilizar um delay entre uma transação e outra.
Resultado esperado: Gráfico de Vazão x Taxa de envio de transações.
Questões: Como a forma como os clientes estão distribuídos na rede, o tipo de transação e a quantidade influencia na medida?

2) Vazão transacional em função do número de nós validadores.
Como o número de participantes do consenso afeta a vazão transacional?
Envia-se uma fila de 100 transações escritas em um arquivo.
Mede-se o tempo para validar as transações utilizando consultas de tempos em tempos ao validador.
É esperado que um aumento no número de nós afete a escalabilidade do PoET e do PBFT de forma significativa.
Questões: Como o tamanho do bloco e o intervalo de bloco influenciam na escalabilidade?
